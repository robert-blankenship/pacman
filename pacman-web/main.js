// Generated by CoffeeScript 1.10.0
(function() {
  var DrawableElement, Space, Tile, Wall, drawMaze, getTileHeight, getTileWidth, init,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DrawableElement = (function() {
    function DrawableElement() {}

    return DrawableElement;

  })();

  Space = (function(superClass) {
    extend(Space, superClass);

    function Space() {
      return Space.__super__.constructor.apply(this, arguments);
    }

    return Space;

  })(DrawableElement);

  Wall = (function(superClass) {
    extend(Wall, superClass);

    function Wall() {
      return Wall.__super__.constructor.apply(this, arguments);
    }

    return Wall;

  })(DrawableElement);

  Tile = (function() {
    function Tile(row, column, skin) {
      this.row = row;
      this.column = column;
      this.skin = skin;
    }

    return Tile;

  })();

  getTileHeight = function(maze, ctx) {
    var tilesY;
    tilesY = maze.map(function(tile) {
      return tile.row;
    }).reduce(function(rowCurrent, rowNext) {
      console.log(rowCurrent, rowNext);
      if (rowNext > rowCurrent) {
        return rowNext;
      } else {
        return rowCurrent;
      }
    });
    return ctx.canvas.height / tilesY;
  };

  getTileWidth = function(maze, ctx) {
    var tilesX;
    tilesX = maze.map(function(tile) {
      return tile.column;
    }).reduce(function(columnCurrent, columnNext) {
      if (columnNext > columnCurrent) {
        return columnNext;
      } else {
        return columnCurrent;
      }
    });
    return ctx.canvas.width / tilesX;
  };

  drawMaze = function(maze, ctx) {
    var tileHeight, tileWidth;
    tileWidth = getTileWidth(maze, ctx);
    tileHeight = getTileHeight(maze, ctx);
    console.log(tileWidth);
    console.log(tileHeight);
    maze.forEach(function(tile) {
      ctx.fillStyle = tile.skin instanceof Space ? "blue" : tile.skin instanceof Wall ? "black" : void 0;
      return ctx.fillRect(tile.row * tileWidth, tile.column * tileHeight, tileWidth, tileHeight);
    });
    return ctx.stroke();
  };

  init = function() {
    var canvas, context, maze, testMaze;
    testMaze = [new Tile(0, 0, new Space()), new Tile(0, 1, new Space()), new Tile(0, 2, new Space()), new Tile(0, 3, new Space()), new Tile(1, 0, new Space()), new Tile(1, 1, new Space()), new Tile(1, 2, new Space()), new Tile(1, 3, new Space()), new Tile(2, 0, new Wall()), new Tile(2, 1, new Wall()), new Tile(2, 2, new Wall()), new Tile(2, 3, new Wall()), new Tile(3, 0, new Wall()), new Tile(3, 1, new Wall()), new Tile(3, 2, new Wall()), new Tile(3, 3, new Wall())];
    maze = testMaze;
    canvas = document.getElementById('game-canvas');
    context = canvas.getContext('2d');
    return drawMaze(maze, context);
  };

  init();

}).call(this);
